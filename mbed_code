
#include "mbed.h"
#include <exception>

#define DT 0.001 // Sample Time
#define KP 0.25f // Proportional Gain for Control System
#define KI 0.0f // Integral Gain for Control System
#define KD 0.01f // Derivative Gain for Control System
#define samples 100 // Number of samples to average for inductive sensors
#define senSlope 13 // slope for feedback gain conversion
#define steering_reference 0.066f // center of servo motor steering range (in PWM)
#define control_threshold 0.01f // percent change threshold to execute new control action


AnalogIn ain(A0); // input from voltage divider
AnalogIn inductor1(A2); // input from inductor 1
AnalogIn inductor2(A1); // input from inductor 2
AnalogIn detectLeft(A3); // input from left landmark sensor (low=landmark detected)
AnalogIn detectRight(A4); // input from right landmark sensor (low=landmark detected)
PwmOut servo(D3); // PWM output to servo

servo.period_ms(20); // set servo frequency to 50 Hz (20 ms period)

InterruptIn Button(BUTTON1); // Onboard button for on/off
bool programRunning = false;

void onButtonPress() {
    programRunning = !programRunning;
}

Button.fall(&onButtonPress);

float calculateIntegral(float error_current, float sample_time, float& area_prior){

   // Calculate the integral using the Euler forward approximation method.
   float area_current = sample_time*error_current + area_prior;
   area_prior = area_current;
   return area_current;

}

float calculateDerivative(float error_current, float error_prior, float sample_time){

    // Calculate the derivative using the Euler forward approximation method.
   float derivative_error = (error_current - error_prior)/sample_time;
   return derivative_error;

}


float calculatePIDOutput(float error_current, float error_prior, float sample_time, float& area_prior, float kp, float ki, float kd){

   // Calculate the integral approximation of the error curve up to the current time.
   float area_current = calculateIntegral(error_current, sample_time, area_prior);

   // Calculate the derivative approximation of the error curve at the current time.
   float error_change = calculateDerivative(error_current, error_prior, sample_time);

   // Calculate the Control Action using the PID Equation
   float action = kp*error_current + ki*area_current + kd*error_change;

   return action;

}

float get_feedback(AnalogIn &inductor1, AnalogIn &inductor2) {
    float left_sensor_sum = 0;
    float right_sensor_sum = 0;
    for (int i = 0; i < samples; i++) {
        left_sensor_sum += inductor1.read();
        right_sensor_sum += inductor2.read();
    }
    float left_sensor_avg = left_sensor_sum/samples;
    float right_sensor_avg = right_sensor_sum/samples;

    printf("   left sensor: %3.3f%", left_sensor_avg);
    printf("   right sensor: %3.3f%", right_sensor_avg);
    if(left_sensor_avg < 0.2 && right_sensor_avg < 0.2) { // Off-track detection
        programRunning = false;
    }

    float feedback = (left_sensor_avg - right_sensor_avg)/senSlope;
    return feedback;
}

void controlUpdate(void){

   // Declare static variables (Values will be carried over to the subsequent function calls)
   // Also this will not override the static variables back to zero during subsequent function calls.
   static float area_prior = 0;
   static float error_prior = 0;

   // Get the feedback value from the sensor
   float feedback = get_feedback(inductor1, inductor2);
    // Get reference value from the user input device
//    float speed_reference = 0

   // Calculate the error term
   float error_current = steering_reference - feedback;

   // Calculate the output of the PID Controller
   float controlAction = calculatePIDOutput(error_current, error_prior, DT, area_prior, KP, KI, KD);

   // Bound the output
    if(abs(controlAction) < 0.02){ // input protection for servo motor
        float current_steering_angle = servo.read();
        float percent_change = ((steering_reference+controlAction)-current_steering_angle)/current_steering_angle;
        printf("    percent change: %3.3f", percent_change);
        if (abs(percent_change) > control_threshold){
            servo.write(steering_reference+controlAction); // Only implements new control action if percent change is above control threshold
        }
    }
    else {
        double sign = (controlAction > 0) - (controlAction < 0);
        // controlAction = controlAction/controlAction*0.02;
        controlAction = 0.02 * sign;
        servo.write(steering_reference+controlAction);
    }
    printf("   servo position: %3.3f% \n\n", servo.read());

   // Save the current error as the prior for the next loop
   error_prior = error_current;
}

int main(){

    if (programRunning) {
        printf("Button pressed! Starting program...\n");
        // Turn motor on
    } else {
        printf("Button pressed! Stopping program...\n");
        // Turn motor off
    }
   Ticker control_ticker;
   control_ticker.attach(&controlUpdate, DT);

}
