
#include "mbed.h"
#include <exception>
#include <cstdio>
#include <Ticker.h>

#define TI_driving 0.001f          // 1kHz sample time
#define TI_steering 0.02f   // 50 Hz sample time
#define Vbat 7.2f           // Battery voltage

// Steering variables
float KP_steering = 0.25; // Proportional Gain
float KD_steering = 0.01; // Derivative Gain
float KI_steering = 0; // Integral Gain
float error_current_steering = 0; // error term
float feedback = 0; // feedback value from inductive sensors
float controlAction = 0.0; // control action from steering controller
float previousError = 0.0;
float errorChange = 0.0;
float integralSum = 0.0; // Area prior
float controllerOutput = 0.0;
float reference = 0.0;
float senSlope = 48; //13
float center = 0.066; // 0.066
float control_threshold = 0.01; //0.01 percent change that must occur for steering control to implement
float steering_bias_constant = 0; // constant that is added to the value from right inductive sensor to center the car

AnalogIn inductor1(A2); // input from inductor 1
AnalogIn inductor2(A0); // input from inductor 2
AnalogIn detectLeft(A3);
AnalogIn detectRight(A4);
PwmOut servo(D3); // PWM output to servo

// Driving variables
float speed_setpoint_1 = 0.3;
float targetSpeed = 0;   // Target wheel speed PWM
float KP_driving = 2.665;   // Proportional gain
float KI_driving = 1.674;   // Integral gain
float KD_driving = 0;
float output = 0;
float bound_output = 0;
float current_speed = 0;
float error_current = 0;
float driving_bias_constant = 0.05;

AnalogIn driving_sensor(A5);     // Sensor reading speed feedback
PwmOut control_output(D6);        // PWM output to control system

// State conditions
bool buttonPressed = false;
bool programRunning = false;

// Function to calculate the integral term using Euler forward approximation
float calculateIntegral(float error_current, float& area_prior, float sample_time) {
   // Integral approximation: area_current = area_prior + (error_current * DT)
   float area_current = area_prior + (error_current * sample_time);
   
   // Update the area prior variable for the next iteration
   area_prior = area_current;
   
   return area_current;
}

// Function to calculate the derivative term using a first-order Taylor series approximation
float calculateDerivative(float error_current, float error_prior, float sample_time) {
   // Derivative approximation: (error_current - error_prior) / DT
   return (error_current - error_prior) / sample_time;
}

// Function to calculate the PID
float calculatePIDOutput(float sample_time, float error_current, float error_prior, float& area_prior, float kp, float ki, float kd){

   // Calculate the integral approximation of the error curve up to the current time.
   float area_current = calculateIntegral(error_current, sample_time, area_prior);

   // Calculate the derivative approximation of the error curve at the current time.
   float error_change = calculateDerivative(error_current, error_prior, sample_time);

   // Calculate the Control Action using the PID Equation
   float action = kp*error_current + ki*area_current + kd*error_change;

   return action;

}

// Takes the average of however many samples from the left and right sensors before calculating sensor feedback
void get_steering_feedback() {

    // read left and right steering sensors
    float left_sensor_sum = 0;
    float right_sensor_sum = 0;
    int samples = 10;
    for (int i = 0; i < samples; i++) {
        left_sensor_sum += inductor1.read();
        right_sensor_sum += inductor2.read();
    }
    float left_sensor_avg = left_sensor_sum/samples;
    float right_sensor_avg = right_sensor_sum/samples + steering_bias_constant;
    printf("   left sensor: %3.3f", left_sensor_avg);
    printf("   right sensor: %3.3f", right_sensor_avg);
    // Off track detection
    // if(left_sensor_avg < 0.2 && right_sensor_avg < 0.2) {
    //     programRunning = false;
    // }

    feedback = (left_sensor_avg - right_sensor_avg)/senSlope;
}

void get_driving_feedback() {

    // read left and right steering sensors
    float tach_sum = 0;
    int samples = 10;
    for (int i = 0; i < samples; i++) {
        tach_sum += driving_sensor.read();
    }
    float tach_sum_avg = tach_sum/samples;

    current_speed = tach_sum_avg;
    printf("    Measured Speed: %f", current_speed);
}

// Main driving function called by the ticker
void drivingUpdate() {
   // Static variables to store values between function calls
   static float area_prior = 0.0f;
   static float error_prior = 0.0f;
   
   // Read sensor feedback and user-defined reference
   float reference = targetSpeed;
   
   // Calculate the current error
   error_current = reference - current_speed + driving_bias_constant;
   
   // Calculate the PID controller output
   output = calculatePIDOutput(TI_driving, error_current, error_prior, area_prior, KP_driving, KI_driving, KD_driving);
   
   // Bound the output to the PWM range [0.0, 1.0]
   bound_output = (fmax(0.0f, fmin(output, 1.0f)));
   
   // Set the PWM duty cycle
   control_output.write(bound_output);
   
   // Update prior error for the next iteration
   error_prior = error_current;
}

// Main steering function called by the ticker
void steeringUpdate()
{
    error_current_steering = reference - feedback;
    if(abs(error_current_steering) < 0.01){
        integralSum = 0;
    }
    errorChange = (error_current_steering - previousError)/TI_steering; // Euler approximation of derivative
    integralSum += error_current_steering*TI_steering;
    controlAction = calculatePIDOutput(TI_steering, error_current_steering, errorChange, integralSum, KP_steering, KI_steering, KD_steering);
    previousError = error_current_steering;
}

InterruptIn Button(BUTTON1);

void onButtonPress() {
    buttonPressed = true; // Set the flag when button is pressed
}

int main()
{
    servo.period_ms(20); // set servo frequency to 50 Hz (20 ms period)
    // Initialize steering Ticker
    Ticker steering_ticker;
    steering_ticker.attach(&steeringUpdate,TI_steering);
    // Initialize driving Ticker
    // Ticker driving_ticker;
    // driving_ticker.attach(&drivingUpdate, TI_driving);

    Button.fall(&onButtonPress);

    while (true) {
        // Check if the button was pressed
        if (buttonPressed) {
            buttonPressed = false; // Reset the flag

            // Toggle the program running state
            programRunning = !programRunning;

            if (programRunning) {
                printf("Button pressed! Starting program...\n");
                targetSpeed = speed_setpoint_1;
                control_output.write(targetSpeed);
            } else {
                printf("Button pressed! Stopping program...\n");
                targetSpeed = 0.0;
                control_output.write(0.0);
            }
        }
        if (programRunning) {
            get_steering_feedback();
            // read driving sensor
            get_driving_feedback();
            drivingUpdate();
            printf("    PI Output: %f", output); 
            // printf("    Bounded Output: %f", bound_output);  
            printf("    Set Speed: %f", targetSpeed);              
            printf("    Error: %f", error_current);
            // printf("    left signal: %3.3f", detectLeft.read());
            // printf("    right signal: %3.3f", detectRight.read());
            // printf("   error: %3.3f", e);
            printf("   integralSum: %3.3f", integralSum);
            printf("   u: %3.3f", controlAction);
            if(abs(controlAction) < 0.02){ // input protection for servo motor
                float percent_change = ((center+controlAction)-servo.read())/servo.read();
                printf("    percent change: %3.3f", percent_change);
                if (abs(percent_change) > control_threshold){
                    servo.write(center+controlAction); // Only implements new control action if percent change is above control threshold
                }
            }
            else {
                float bounded_controlAction = (fmax(-0.02f, fmin(controlAction, 0.02f)));
                servo.write(center+bounded_controlAction);
            }
            printf("   servo position: %3.3f \n\n", servo.read());
        }
    }
}
